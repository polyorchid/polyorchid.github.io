<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Puddle Planet â€” Idle Clicker</title>
  <style>
    :root{
      --bg:#0b1020; /* scene background */
      --panel:#0f152c; /* opaque UI panels */
      --panel-2:#121a36;
      --accent:#6ad0ff;
      --accent-2:#9ee37d;
      --accent-3:#ffd166;
      --danger:#ff6b6b;
      --text:#e8f2ff;
      --muted:#9bb2d9;
      --shadow: rgba(0,0,0,0.35);
    }
    html, body { height: 100%; }
    body{
      margin:0; background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      overflow:hidden; user-select:none;
    }
    /* Layout */
    #app { position:relative; width:100vw; height:100vh; }
    #scene { position:absolute; inset:0; width:100%; height:100%; image-rendering: pixelated; }

    /* Top bar */
    .topbar{ position:absolute; left:12px; right:12px; top:12px; height:64px; display:flex; gap:12px; align-items:center; background:var(--panel); box-shadow: 0 8px 20px var(--shadow); border-radius:16px; padding:10px 14px; }
    .stat{ display:flex; gap:8px; align-items:center; background:var(--panel-2); border-radius:12px; padding:8px 12px; }
    .stat .label{ color:var(--muted); font-size:12px; }
    .stat .value{ font-weight:700; letter-spacing:0.3px; }
    .grow{ flex:1; }

    .bar{ position:relative; height:12px; background:#0d1330; border-radius:999px; overflow:hidden; box-shadow:inset 0 0 0 1px rgba(255,255,255,0.06); }
    .bar > .fill{ position:absolute; left:0; top:0; bottom:0; width:0%; background:linear-gradient(90deg, var(--accent), #8bc7ff); }
    .bar > .tick{ position:absolute; top:0; bottom:0; width:2px; background:rgba(255,255,255,.2); }

    .overflow-chip{ display:flex; gap:8px; align-items:center; background:#14223a; border-radius:999px; padding:8px 12px; box-shadow:inset 0 0 0 1px rgba(255,255,255,0.08); }
    .btn{ cursor:pointer; border:none; border-radius:12px; background: var(--accent); color:#001018; padding:8px 12px; font-weight:700; box-shadow:0 8px 18px rgba(106,208,255,0.25); transition: transform .04s ease; }
    .btn:hover{ transform: translateY(-1px); }
    .btn:disabled{ opacity:.5; filter:grayscale(40%); cursor:not-allowed; }
    .btn.secondary{ background:#1d2a4a; color:var(--text); box-shadow:none; }
    .btn.warning{ background: var(--danger); color:#160505; box-shadow:0 8px 18px rgba(255,107,107,.2) }

    /* Right shop */
    .rightbar{ position:absolute; right:12px; top:92px; bottom:12px; width:360px; display:flex; flex-direction:column; gap:12px; }
    .panel{ flex:1; display:flex; flex-direction:column; gap:8px; background: var(--panel); border-radius:16px; padding:10px; box-shadow:0 12px 26px var(--shadow); min-height:120px; overflow:hidden; }
    .panel h3{ margin:4px 6px 6px; font-size:14px; color:var(--muted); letter-spacing:.5px; text-transform:uppercase; }
    .list{ overflow:auto; padding:6px; display:grid; gap:8px; align-content:start; }
    .card{ background:var(--panel-2); border-radius:14px; padding:10px; display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center; box-shadow: inset 0 0 0 1px rgba(255,255,255,.04); }
    .card .title{ font-weight:700; }
    .card .sub{ color:var(--muted); font-size:12px; }
    .card .actions{ display:flex; gap:6px; }

    /* Pause / Settings */
    .top-right{ position:absolute; right:24px; top:24px; display:flex; gap:8px; z-index:5; }

    .badge{ background:#14223a; padding:4px 8px; border-radius:8px; font-size:12px; color:var(--muted); }

    .modal{ position:absolute; inset:0; background:rgba(0,0,0,.5); display:none; align-items:center; justify-content:center; z-index:9; }
    .modal.show{ display:flex; }
    .modal .sheet{ width:min(760px, 92vw); background:var(--panel); border-radius:18px; padding:16px; box-shadow:0 30px 60px rgba(0,0,0,.55); }

    /* Helper */
    .row{ display:flex; gap:8px; align-items:center; }
    .col{ display:flex; flex-direction:column; gap:8px; }
    .muted{ color:var(--muted); }

    /* Scroll styling */
    ::-webkit-scrollbar{ width:10px; height:10px; }
    ::-webkit-scrollbar-thumb{ background:#1b2a4a; border-radius:999px; }
    ::-webkit-scrollbar-track{ background:#0d1330; border-radius:999px; }
  </style>
</head>
<body>
<div id="app">
  <canvas id="scene"></canvas>

  <!-- Top bar -->
  <div class="topbar">
    <div class="stat"><span class="label">Water</span><span id="water" class="value">0</span></div>
    <div class="stat"><span class="label">RPS</span><span id="rps" class="value">0</span></div>
    <div class="stat"><span class="label">CP</span><span id="cp" class="value">1</span></div>

    <div class="grow col">
      <div class="row" style="gap:12px; align-items:center;">
        <span class="label">Milestone</span>
        <div class="bar grow" id="milestoneBar"><div class="fill"></div></div>
        <span id="tierLabel" class="badge">Puddle</span>
      </div>
      <div class="row" style="gap:12px; align-items:center;">
        <span class="label">Overflow</span>
        <div class="bar grow" id="overflowBar"><div class="fill"></div></div>
        <button id="burstBtn" class="btn" disabled>Burst Ã—2 (10s)</button>
      </div>
    </div>

    <div class="row">
      <button id="pauseBtn" class="btn secondary">Pause</button>
      <button id="settingsBtn" class="btn secondary">Settings</button>
    </div>
  </div>

  <!-- Right shop -->
  <div class="rightbar">
    <div class="panel" style="min-height:40%;">
      <h3>Storm Upgrades</h3>
      <div class="list" id="stormList"></div>
    </div>
    <div class="panel" style="min-height:35%;">
      <h3>Utility Upgrades</h3>
      <div class="list" id="utilList"></div>
    </div>
    <div class="panel" style="min-height:120px;">
      <h3>Prestige</h3>
      <div class="col" style="padding:8px;">
        <div><span class="muted">Vapor:</span> <b id="vapor">0</b> &mdash; <span class="muted">Condensation:</span> <b id="condenseBonus">+0% RPS, +0% CP</b></div>
        <button id="prestigeBtn" class="btn warning" disabled>Hydrologic Cycle (Reset for Vapor)</button>
        <div class="muted" style="font-size:12px;">V = âŒŠ ln(1 + totalW / 1e9) Ã— 10 âŒ‹</div>
      </div>
    </div>
  </div>

  <!-- Settings modal -->
  <div class="modal" id="settingsModal">
    <div class="sheet">
      <h2 style="margin:4px 0 12px;">Settings</h2>
      <div class="row" style="flex-wrap:wrap; gap:12px;">
        <label class="stat"><input id="muteAll" type="checkbox" style="margin-right:8px;">Mute All</label>
        <label class="stat"><input id="muteRain" type="checkbox" style="margin-right:8px;">Mute Rain</label>
        <label class="stat"><input id="muteWind" type="checkbox" style="margin-right:8px;">Mute Wind</label>
        <label class="stat"><input id="muteThunder" type="checkbox" style="margin-right:8px;">Mute Thunder</label>
        <label class="stat"><input id="muteUI" type="checkbox" style="margin-right:8px;">Mute UI</label>
      </div>
      <div style="height:8px"></div>
      <div class="row" style="justify-content:flex-end; gap:8px;">
        <button class="btn secondary" id="closeSettings">Close</button>
      </div>
    </div>
  </div>

  <!-- Audio placeholders (add your files later) -->
  <audio id="sfx_rain" loop src=""></audio>
  <audio id="sfx_wind" loop src=""></audio>
  <audio id="sfx_thunder" src=""></audio>
  <audio id="sfx_ui" src=""></audio>
</div>

<script>
(function(){
  // ======== Utility: number formatting ========
  const SUFFIXES = ["","K","M","B","T","Qa","Qi","Sx","Sp","Oc","No","Dc"]; // short-hand
  function fmt(n){
    if (!isFinite(n)) return 'âˆž';
    if (n < 1000) return Math.floor(n).toLocaleString();
    let tier = Math.floor(Math.log10(n)/3);
    tier = Math.min(tier, SUFFIXES.length-1);
    const scaled = n / Math.pow(10, tier*3);
    return (scaled >= 100 ? Math.round(scaled) : scaled >= 10 ? scaled.toFixed(1) : scaled.toFixed(2)) + SUFFIXES[tier];
  }
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); }
  function now(){ return performance.now(); }

  // ======== Economy config ========
  const Tiers = [
    {name:'Puddle', threshold:0},
    {name:'Curb', threshold:1_000},
    {name:'Street', threshold:100_000},
    {name:'City', threshold:10_000_000},
    {name:'Metro', threshold:1_000_000_000},
    {name:'State', threshold:100_000_000_000},
    {name:'Continent', threshold:10_000_000_000_000},
    {name:'World', threshold:1_000_000_000_000_000}
  ];

  const StormUpgrades = [
    { id:'light', name:'Light Rain', baseCost:50, baseRps:1,   effect:'sparse' },
    { id:'shower', name:'Rain Shower', baseCost:500, baseRps:8, effect:'denser' },
    { id:'storm', name:'Storm', baseCost:5_000, baseRps:60, effect:'wind' },
    { id:'thunder', name:'Thunderstorm', baseCost:50_000, baseRps:450, effect:'lightning' },
    { id:'derecho', name:'Derecho', baseCost:600_000, baseRps:3_800, effect:'diagonal' },
    { id:'hurricane', name:'Hurricane', baseCost:8_000_000, baseRps:28_000, effect:'spiral' },
    { id:'river', name:'Atmospheric River', baseCost:120_000_000, baseRps:210_000, effect:'band' },
    { id:'megastorm', name:'Megastorm', baseCost:2_000_000_000, baseRps:1_600_000, effect:'rumble' },
  ];
  const UTIL = [
    { id:'drops', name:'Bigger Drops', desc:'+CP & splash radius', type:'cpFlat', base:5, baseCost:150, costScale:1.25 },
    { id:'seeding', name:'Cloud Seeding', desc:'+RPS multiplier', type:'rpsMult', base:0.05, baseCost:1_000, costScale:1.35 },
    { id:'drains', name:'Clog Drains', desc:'Less evaporation', type:'evapReduce', base:0.15, baseCost:2_500, costScale:1.4 },
    { id:'barometer', name:'Barometer', desc:'Longer Overflow, fills faster', type:'overflow', base:0.10, baseCost:4_000, costScale:1.35 },
  ];
  const COST_SCALE = 1.15; // per level for storm

  // ======== Game State ========
  const state = {
    water: 0,
    totalWater: 0,
    rpsBase: 0, // from storm levels
    rpsMult: 1, // from utilities and buffs
    rpsBuffMult: 1, // temporary buffs (Overflow etc.)
    cpFlat: 0,  // from Bigger Drops etc.
    evaporationEnabled: true,
    evapRate: 0.001, // 0.1% per second base
    evapReduce: 0, // reduced by Clog Drains
    overflow: { value: 0, max: 100, active: false, until: 0, fillRate: 7 },
    zoom: { tier:0, scale:2.2, targetScale:2.2, animStart:0, animDur:1400 },
    screenShake: 0,
    rngPhase: 0,
    prestige: { vapor: 0, rpsBonus: 0, cpBonus: 0 },
    storms: {},
    utils: {},
    ach: {},
    lastUpdate: performance.now(),
    paused:false,
    settings:{ muteAll:false, rain:false, wind:false, thunder:false, ui:false },
  };
  StormUpgrades.forEach(s=> state.storms[s.id] = { level:0 });
  UTIL.forEach(u=> state.utils[u.id] = { level:0 });

  // ======== DOM refs ========
  const elWater = document.getElementById('water');
  const elRps = document.getElementById('rps');
  const elCp = document.getElementById('cp');
  const elTier = document.getElementById('tierLabel');
  const milestoneBar = document.getElementById('milestoneBar');
  const overflowBar = document.getElementById('overflowBar');
  const burstBtn = document.getElementById('burstBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const settingsBtn = document.getElementById('settingsBtn');
  const stormList = document.getElementById('stormList');
  const utilList = document.getElementById('utilList');
  const prestigeBtn = document.getElementById('prestigeBtn');
  const elVapor = document.getElementById('vapor');
  const elCondense = document.getElementById('condenseBonus');

  const settingsModal = document.getElementById('settingsModal');
  const chkMuteAll = document.getElementById('muteAll');
  const chkRain = document.getElementById('muteRain');
  const chkWind = document.getElementById('muteWind');
  const chkThunder = document.getElementById('muteThunder');
  const chkUI = document.getElementById('muteUI');
  const btnCloseSettings = document.getElementById('closeSettings');

  // Audio placeholders (will play only if you add src)
  const sfx = {
    rain: document.getElementById('sfx_rain'),
    wind: document.getElementById('sfx_wind'),
    thunder: document.getElementById('sfx_thunder'),
    ui: document.getElementById('sfx_ui'),
  };
  function playSfx(key){
    try{
      if(state.settings.muteAll) return;
      if(key==='rain' && state.settings.rain) return;
      if(key==='wind' && state.settings.wind) return;
      if(key==='thunder' && state.settings.thunder) return;
      if(key==='ui' && state.settings.ui) return;
      if(!sfx[key].src) return; // no file set yet
      sfx[key].currentTime = 0; sfx[key].play();
    }catch(e){}
  }
  function loopIfHasSrc(key){
    const a = sfx[key];
    if(a && a.src && !state.settings.muteAll){ if(a.paused) a.play().catch(()=>{}); }
  }

  // ======== UI Build ========
  function buildShop(){
    stormList.innerHTML = '';
    StormUpgrades.forEach(st => {
      const level = state.storms[st.id].level;
      const cost1 = nextStormCost(st, level);
      const rpsGain = st.baseRps; // per level
      const div = document.createElement('div');
      div.className = 'card';
      div.innerHTML = `
        <div>
          <div class="title">${st.name} <span class="muted">Lv ${level}</span></div>
          <div class="sub">+${fmt(rpsGain)} RPS / lvl &bull; Next: <b>${fmt(cost1)} W</b></div>
        </div>
        <div class="actions">
          <button class="btn buy1">+1</button>
          <button class="btn secondary buy10">+10</button>
          <button class="btn secondary buyMax">Max</button>
        </div>`;
      div.querySelector('.buy1').onclick = ()=> buyStorm(st.id, 1);
      div.querySelector('.buy10').onclick = ()=> buyStorm(st.id, 10);
      div.querySelector('.buyMax').onclick = ()=> buyStormMax(st.id);
      stormList.appendChild(div);
    });

    utilList.innerHTML = '';
    UTIL.forEach(u=>{
      const L = state.utils[u.id].level;
      const cost = nextUtilCost(u, L);
      const div = document.createElement('div');
      div.className = 'card';
      div.innerHTML = `
        <div>
          <div class="title">${u.name} <span class="muted">Lv ${L}</span></div>
          <div class="sub">${u.desc} &bull; Next: <b>${fmt(cost)} W</b></div>
        </div>
        <div class="actions">
          <button class="btn buy1">Buy</button>
        </div>`;
      div.querySelector('.buy1').onclick = ()=> buyUtil(u.id);
      utilList.appendChild(div);
    });
  }

  function nextStormCost(st, level){ return Math.round(st.baseCost * Math.pow(COST_SCALE, level)); }
  function sumStormCost(st, level, n){
    const r = COST_SCALE;
    const first = st.baseCost * Math.pow(r, level);
    const sum = first * (Math.pow(r, n) - 1) / (r - 1);
    return Math.round(sum);
  }
  function stormMaxAffordable(st){
    const r = COST_SCALE; const level = state.storms[st.id].level; const W = state.water; const base = st.baseCost * Math.pow(r, level);
    if (W < base) return 0;
    const n = Math.floor( Math.log( 1 + (W*(r-1))/base ) / Math.log(r) );
    return Math.max(0, n|0);
  }

  function nextUtilCost(u, level){ return Math.round(u.baseCost * Math.pow(u.costScale, level)); }

  function buyStorm(id, n){
    const st = StormUpgrades.find(s=>s.id===id); const lv = state.storms[id].level;
    if (n===1){
      const cost = nextStormCost(st, lv); if (state.water < cost) return buzz();
      state.water -= cost; state.storms[id].level++; state.rpsBase += st.baseRps; log(`Bought ${st.name} +1`);
      if(id==='light' && !state.ach.firstDrip){ state.ach.firstDrip = true; log('ðŸ… Achievement: First Drip'); }
    } else { // buy N
      const cost = sumStormCost(st, lv, n); if (state.water < cost) return buzz();
      state.water -= cost; state.storms[id].level += n; state.rpsBase += st.baseRps * n; log(`Bought ${st.name} +${n}`);
    }
    onStormEffectChange(); buildShop();
  }
  function buyStormMax(id){
    const st = StormUpgrades.find(s=>s.id===id); const L = stormMaxAffordable(st);
    if (L<=0) return buzz();
    const cost = sumStormCost(st, state.storms[id].level, L);
    state.water -= cost; state.storms[id].level += L; state.rpsBase += st.baseRps * L; log(`Bought ${st.name} +${L}`);
    onStormEffectChange(); buildShop();
  }

  function buyUtil(id){
    const u = UTIL.find(x=>x.id===id); const L = state.utils[id].level; const cost = nextUtilCost(u, L);
    if (state.water < cost) return buzz();
    state.water -= cost; state.utils[id].level++;
    switch(u.type){
      case 'cpFlat': state.cpFlat += u.base; break;
      case 'rpsMult': state.rpsMult *= (1 + u.base); break;
      case 'evapReduce': state.evapReduce = clamp(state.evapReduce + u.base, 0, .95); break;
      case 'overflow': state.overflow.max *= (1 + u.base); state.overflow.fillRate *= (1 + u.base*0.5); break;
    }
    log(`Upgraded ${u.name} to Lv ${state.utils[id].level}`);
    buildShop();
  }

  function buzz(){ playSfx('ui'); }

  // ======== Core math ========
  function softcapRps(rps){
    if (rps < 1e8) return rps;
    return Math.pow(rps, 0.98);
  }
  function computeRps(){ return softcapRps(state.rpsBase) * state.rpsMult * state.rpsBuffMult * (1 + state.prestige.rpsBonus); }
  function computeCp(){ const rps = computeRps(); const base = Math.max(1, Math.round(0.01 * rps)); return (base + state.cpFlat) * (1 + state.prestige.cpBonus); }

  // ======== Prestige ========
  function vaporFrom(total){ return Math.floor( Math.log(1 + (total/1_000_000_000)) * 10 ); }
  function updatePrestigeUI(){
    elVapor.textContent = state.prestige.vapor.toLocaleString();
    elCondense.textContent = `+${Math.round(state.prestige.rpsBonus*100)}% RPS, +${Math.round(state.prestige.cpBonus*100)}% CP`;
    const canPrestige = state.zoom.tier >= 7; // at World
    prestigeBtn.disabled = !canPrestige;
  }
  function doPrestige(){
    if (state.zoom.tier < 7) return;
    const gained = vaporFrom(state.totalWater);
    if (gained <= 0) { log('Not enough for Vapor. Push further!'); return; }
    state.prestige.vapor += gained;
    state.prestige.rpsBonus += gained * 0.025; // +2.5% per Vapor
    state.prestige.cpBonus += gained * 0.01;   // +1% per Vapor
    log(`âœ¨ Prestige! Gained ${gained} Vapor.`);
    hardReset(false); // keep prestige
    save();
  }

  // ======== Save / Load ========
  const SAVE_KEY = 'puddle-planet-save-v1';
  function save(){ try{ localStorage.setItem(SAVE_KEY, JSON.stringify(state)); }catch(e){} }
  function load(){ try{ const s = JSON.parse(localStorage.getItem(SAVE_KEY)||'null'); if(!s) return; Object.assign(state, s);
    state.lastUpdate = performance.now();
  }catch(e){} }
  function hardReset(clearPrestige=true){
    const keep = clearPrestige ? { prestige:{ vapor:0, rpsBonus:0, cpBonus:0 } } : { prestige: state.prestige };
    Object.assign(state, {
      ...keep,
      water:0, totalWater:0,
      rpsBase:0, rpsMult:1, rpsBuffMult:1, cpFlat:0,
      evaporationEnabled:true, evapRate:0.001, evapReduce:0,
      overflow:{ value:0, max:100, active:false, until:0, fillRate:7 },
      zoom:{ tier:0, scale:2.2, targetScale:2.2, animStart:0, animDur:1400 },
      screenShake:0, rngPhase:0,
      storms:{}, utils:{}, ach:{}, paused:false,
      settings: state.settings,
      lastUpdate: performance.now(),
    });
    StormUpgrades.forEach(s=> state.storms[s.id] = { level:0 });
    UTIL.forEach(u=> state.utils[u.id] = { level:0 });
    buildShop();
    log('World reset. Fresh skies.');
  }

  // ======== Logging (disabled UI) ========
  function log(_){} // keep calls but do nothing

  // ======== Canvas Scene ========
  const canvas = document.getElementById('scene');
  const ctx = canvas.getContext('2d');
  let W=innerWidth, H=innerHeight, dpr=window.devicePixelRatio||1;
  function resize(){
    W = innerWidth; H = innerHeight; dpr = window.devicePixelRatio||1;
    canvas.width = Math.round(W*dpr); canvas.height = Math.round(H*dpr);
    canvas.style.width = W+'px'; canvas.style.height = H+'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize); resize();

  // Rain particle pool
  const drops = [];
  function spawnDrops(target){
    while(drops.length < target){ drops.push({x:Math.random()*W, y:Math.random()*H, z:Math.random(), vx:0, vy: 120 + Math.random()*240, len: 6 + Math.random()*8, life: Math.random()*100}); }
    while(drops.length > target){ drops.pop(); }
  }

  // Lightning flash overlay
  let flash=0;
  let _buffUntil = 0;        // lightning timer
  let lightningActive = false; // prevent stacking
  function triggerLightning(){
    flash = 1; state.screenShake = Math.max(state.screenShake, 6);
    playSfx('thunder');
    if (state.storms.thunder.level>0){
      const endAt = now()+5000;
      if (!lightningActive){ state.rpsBuffMult *= 2; lightningActive = true; }
      _buffUntil = Math.max(_buffUntil, endAt);
      log('âš¡ Lightning Chain! RPS Ã—2 for 5s');
    }
  }

  // Visual tier names
  function tierName(i){ return Tiers[i]?.name || 'World'; }

  function onStormEffectChange(){
    if (state.storms.light.level + state.storms.shower.level > 0) loopIfHasSrc('rain');
    if (state.storms.storm.level + state.storms.derecho.level + state.storms.hurricane.level > 0) loopIfHasSrc('wind');
  }

  // ======== Input ========
  canvas.addEventListener('click', (e)=>{
    if(state.paused) return;
    const cp = computeCp();
    state.water += cp; state.totalWater += cp; state.overflow.value = Math.min(state.overflow.max, state.overflow.value + state.overflow.fillRate);
    state.screenShake = Math.min(4, state.screenShake + 0.7);
    ripple(e.offsetX, e.offsetY);
  });

  // Simple ripple store
  const ripples=[]; function ripple(x,y){ ripples.push({x,y,r:2,alpha:1}); if(ripples.length>80) ripples.shift(); }

  burstBtn.addEventListener('click', ()=>{
    if (state.overflow.value < state.overflow.max) return;
    const dur = 10_000 * (1 + (state.utils.barometer.level*0.15));
    state.rpsBuffMult *= 2; state.overflow.active = true; state.overflow.until = now()+dur; state.overflow.value = 0; log('ðŸ’§ Overflow burst! RPS Ã—2');
  });

  pauseBtn.onclick = ()=>{ state.paused = !state.paused; pauseBtn.textContent = state.paused ? 'Resume' : 'Pause'; if(!state.paused) state.lastUpdate = performance.now(); };
  settingsBtn.onclick = ()=> settingsModal.classList.add('show');
  btnCloseSettings.onclick = ()=> settingsModal.classList.remove('show');
  chkMuteAll.onchange = ()=> state.settings.muteAll = chkMuteAll.checked;
  chkRain.onchange = ()=> state.settings.rain = chkRain.checked;
  chkWind.onchange = ()=> state.settings.wind = chkWind.checked;
  chkThunder.onchange = ()=> state.settings.thunder = chkThunder.checked;
  chkUI.onchange = ()=> state.settings.ui = chkUI.checked;

  prestigeBtn.onclick = doPrestige;

  // ======== Milestones / Zoom ========
  function checkMilestones(){
    let t = state.zoom.tier;
    while (t+1 < Tiers.length && state.totalWater >= Tiers[t+1].threshold){ t++; }
    if (t !== state.zoom.tier){
      state.zoom.tier = t; elTier.textContent = tierName(t);
      const target = mapTierToScale(t);
      state.zoom.targetScale = target; state.zoom.animStart = now();
      log(`ðŸŽ¯ Milestone: ${tierName(t)} reached!`);
      if (t>=7 && !state.ach.global){ state.ach.global = true; log('ðŸ… Achievement: Global Flooded'); }
    }

    const nextTh = (Tiers[state.zoom.tier+1]?.threshold) || Tiers[Tiers.length-1].threshold;
    const prevTh = Tiers[state.zoom.tier].threshold;
    const span = nextTh - prevTh; const prog = clamp((state.totalWater - prevTh)/Math.max(1,span), 0, 1);
    milestoneBar.querySelector('.fill').style.width = (prog*100).toFixed(2)+'%';
  }
  function mapTierToScale(t){
    const scales = [2.2, 1.8, 1.45, 1.2, 0.95, 0.75, 0.6, 0.5];
    return scales[Math.min(t, scales.length-1)];
  }

  // ======== Scene rendering ========
  function drawScene(dt){
    const ts = now();
    ctx.clearRect(0,0,W,H);

    const shake = state.screenShake>0 ? (Math.random()-0.5)*state.screenShake : 0;
    if (state.screenShake>0) state.screenShake = Math.max(0, state.screenShake - dt*0.008);

    const z = state.zoom; let s = z.scale;
    if (Math.abs(z.scale - z.targetScale) > 0.001){
      const t = clamp((ts - z.animStart)/z.animDur, 0, 1);
      s = z.scale = z.scale + (z.targetScale - z.scale)*easeOutCubic(t);
    }

    ctx.save();
    ctx.translate(W/2 + shake, H/2 + shake);
    ctx.scale(s, s);
    ctx.translate(-W/2, -H/2);

    const palette = [ ['#0b1020','#0d1b3a'], ['#0b1426','#0b2248'], ['#0a1833','#0a2e57'], ['#091a2a','#173d64'], ['#0a2230','#1e4a62'], ['#0a1e23','#1a4453'], ['#08202b','#18465a'], ['#07212b','#0f3b4a'] ];
    const grad = ctx.createLinearGradient(0,0,0,H);
    const p = palette[Math.min(state.zoom.tier, palette.length-1)];
    grad.addColorStop(0,p[0]); grad.addColorStop(1,p[1]);
    ctx.fillStyle = grad; ctx.fillRect(0,0,W,H);

    const cloudAmp = 10 + state.zoom.tier*6;
    drawCloudLayer(0.2, ts*0.00005, cloudAmp*0.5);
    drawCloudLayer(0.5, ts*0.00008, cloudAmp*0.8);
    drawCloudLayer(0.8, ts*0.00012, cloudAmp*1.0);

    drawWaterBody();

    if (state.storms.storm.level + state.storms.derecho.level + state.storms.hurricane.level > 0){ drawWindLines(ts); }

    const rps = computeRps();
    const baseDensity = 80; // tune
    const density = clamp(Math.round(baseDensity + Math.log10(1 + rps) * 80 + totalStormLevels()*8), 40, 1800);
    spawnDrops(density);

    drawRain(ts, dt);
    drawRipples(dt);

    if(state.zoom.tier>=3){ drawCityHints(ts); }

    if (flash>0){ ctx.fillStyle = `rgba(200,230,255,${flash})`; ctx.fillRect(0,0,W,H); flash = Math.max(0, flash - dt*0.01); }

    ctx.restore();

    overflowBar.querySelector('.fill').style.width = (state.overflow.value/state.overflow.max*100).toFixed(1)+'%';
    burstBtn.disabled = !(state.overflow.value >= state.overflow.max && !state.overflow.active);
  }

  function totalStormLevels(){ return StormUpgrades.reduce((a,s)=>a+state.storms[s.id].level,0); }

  function drawCloudLayer(alpha, speed, amp){
    ctx.save();
    ctx.globalAlpha = 0.10 + alpha*0.25;
    const y = Math.sin(now()*speed)*amp + H*0.1*alpha;
    for(let i=-2;i<6;i++){
      const x = (i*260 + (now()*40*speed)) % (W+260) - 130;
      drawCloud(x, y + i%2*12, 180, 40);
    }
    ctx.restore();
  }
  function drawCloud(x,y,w,h){
    ctx.fillStyle = '#b9d6ff22';
    roundedRect(x,y,w,h,20);
    roundedRect(x+30,y-10,w*0.6,h,18);
    roundedRect(x+80,y-6,w*0.4,h,16);
  }
  function roundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); ctx.fill(); }

  function drawWaterBody(){
    ctx.save();
    ctx.globalAlpha = 0.9;
    const size = 140 + state.zoom.tier*80; // grows with tier
    const cx = W*0.5, cy = H*0.75;
    const wave = Math.sin(now()*0.003)*3 + (state.storms.hurricane.level>0 ? Math.sin(now()*0.006)*4 : 0);
    ctx.fillStyle = '#2aa3ff66';
    ctx.beginPath();
    ctx.ellipse(cx, cy, size+wave, size*0.35+wave*0.4, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.strokeStyle = '#aee3ff66'; ctx.lineWidth = 2; ctx.beginPath(); ctx.ellipse(cx, cy-6, size*0.6, size*0.18, 0, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  function drawWindLines(ts){
    ctx.save();
    ctx.globalAlpha = 0.15;
    const diag = state.storms.derecho.level>0 ? 0.6 : 0;
    for(let i=0;i<8 + state.zoom.tier*2;i++){
      const y = (ts*0.08 + i*120) % (H+120) - 60;
      ctx.strokeStyle = '#c7e9ff33'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(0, y - diag*80); ctx.lineTo(W, y + diag*80); ctx.stroke();
    }
    ctx.restore();
  }

  function drawRain(ts, dt){
    const diagonal = state.storms.derecho.level>0 ? 1 : 0;
    const windX = diagonal ? 180 : 0;
    const streak = 8 + (state.storms.megastorm.level>0 ? 6 : 0);
    ctx.strokeStyle = '#9dd5ff55'; ctx.lineWidth = 1.5;
    for (let i=0;i<drops.length;i++){
      const d = drops[i];
      d.x += (windX + d.vx) * dt*0.001; d.y += d.vy * dt*0.001;
      if (d.x > W+20 || d.y > H+20){ d.x = Math.random()*W; d.y = -10; }
      ctx.beginPath(); ctx.moveTo(d.x, d.y); ctx.lineTo(d.x - (diagonal?streak:0), d.y - streak); ctx.stroke();
      if (d.y > H*0.72 && Math.random()<0.003) ripples.push({x:d.x, y:H*0.75, r:2, alpha:0.7});
    }

    if (state.storms.thunder.level>0 && Math.random() < 0.0015 * (1 + state.storms.thunder.level*0.02)){
      triggerLightning();
    }
  }

  function drawRipples(dt){
    ctx.save();
    for(let i=ripples.length-1;i>=0;i--){
      const r = ripples[i]; r.r += dt*0.06; r.alpha -= dt*0.0009; if(r.alpha<=0){ ripples.splice(i,1); continue; }
      ctx.strokeStyle = `rgba(174,227,255,${r.alpha})`; ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.arc(r.x, r.y, r.r, 0, Math.PI*2); ctx.stroke();
    }
    ctx.restore();
  }

  function drawCityHints(ts){
    ctx.save();
    const y = H*0.55; const n = 20; const gap = W/n;
    for(let i=0;i<n;i++){
      const x = i*gap + 20; const h = 20 + Math.random()*80;
      ctx.fillStyle = '#0e1f38'; ctx.fillRect(x, y-h, 24, h);
      if (state.storms.megastorm.level>0 && Math.random()<0.05){ ctx.fillStyle = '#ffe9a844'; ctx.fillRect(x+6, y-h+6, 4, 6); }
    }
    ctx.restore();
  }

  // ======== Game loop ========
  function step(){
    requestAnimationFrame(step);
    const t = performance.now();
    const dt = Math.min(80, t - state.lastUpdate); // clamp delta
    if(state.paused){ state.lastUpdate = t; return; }

    // expire lightning buff
    if (_buffUntil && t > _buffUntil){ if (lightningActive){ state.rpsBuffMult = Math.max(1, state.rpsBuffMult/2); lightningActive = false; } _buffUntil = 0; }
    // expire overflow buff
    if (state.overflow.active && t > state.overflow.until){ state.overflow.active = false; state.rpsBuffMult = Math.max(1, state.rpsBuffMult/2); }

    // production & evaporation
    const rps = computeRps();
    const produced = rps * (dt/1000);
    state.water += produced; state.totalWater += produced;

    if (state.evaporationEnabled){
      const evap = state.evapRate * (1 - state.evapReduce) * state.water * (dt/1000);
      state.water = Math.max(0, state.water - evap);
    }

    // overflow passive fill slight
    state.overflow.value = Math.min(state.overflow.max, state.overflow.value + (dt/1000)* (1 + state.zoom.tier*0.1));

    // random Sunbreak
    if (Math.random() < 0.00005){
      const loss = Math.min(state.water*0.03, state.totalWater*0.0005);
      state.water = Math.max(0, state.water - loss);
      log('â˜€ Sunbreak! Evaporation spiked briefly.');
    }

    // UI numbers
    elWater.textContent = fmt(state.water);
    elRps.textContent = fmt(rps) + (state.overflow.active ? ' (Ã—2)' : '');
    elCp.textContent = fmt(computeCp());

    checkMilestones();
    updatePrestigeUI();

    drawScene(dt);

    state.lastUpdate = t;
  }

  // ======== Init ========
  buildShop(); load(); buildShop();
  log('Welcome to Puddle Planet. Click to add drops.');
  onStormEffectChange();
  step();

  // Auto-save
  setInterval(save, 30_000);
  window.addEventListener('beforeunload', save);
  document.addEventListener('visibilitychange', ()=>{ if (document.hidden) save(); });

})();
</script>
</body>
</html>
